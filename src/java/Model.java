import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Set;

import jason.environment.grid.Location;

// a grid map
public class Model {
	// the width, height of the grid map
	private int width, height;
	// the set of obstacles in this map
	private Set<Location> obstacles;
	// the set of possible Victims;
	private Set<Location> victimsToVisit;
	// costs from one victim to another victim
	private HashMap<Location, HashMap<Location, Integer>> costToEachOther;
	private HashMap<Location, HashMap<Location, LinkedList<Location>>> pathToEachOther;
	// constructor 1 with width and height
	public Model(int W_GRID, int H_GRID) {
		width = W_GRID;
		height = H_GRID;
		obstacles = new HashSet<Location>();
	}
	// constructor 2 with width, height, set of obstacles and whether there are walls
	public Model(int W_GRID, int H_GRID, Set<Location> setOfObstacles, Set<Location> setOfPossibleVictims, boolean addWalls) {
		width = W_GRID;
		height = H_GRID;
		obstacles = setOfObstacles;
		victimsToVisit = setOfPossibleVictims;
		costToEachOther = new HashMap<Location, HashMap<Location, Integer>>();
		pathToEachOther = new HashMap<Location, HashMap<Location, LinkedList<Location>>>();
		computeCosts();
		if (addWalls) {
			for (int w=0; w <= width-1; w++) {
				obstacles.add(new Location(w,0));
				obstacles.add(new Location(w,height-1));
			}
			for (int h=0; h <= height-1; h++) {
				obstacles.add(new Location(0,h));
				obstacles.add(new Location(width-1,h));
			}
		}
	}
	
	// compute the cost it will take to get from one victim to another
	public void computeCosts() {
		for (Location vicOne: victimsToVisit) {
			pathToEachOther.put(vicOne, new HashMap<Location, LinkedList<Location>>());
			costToEachOther.put(vicOne, new HashMap<Location, Integer>());
			for (Location vicTwo: victimsToVisit) {
				// can be easily further optimized, but I am lazy, hopefully someone will do this
				if (vicOne != vicTwo) {
					LinkedList<Location> path = aStarPathFinding(vicOne, vicTwo);
					pathToEachOther.get(vicOne).put(vicTwo, path);
					costToEachOther.get(vicOne).put(vicTwo, path.size());
					System.out.print("[Location (" + vicOne.toString() + ") to (" + vicTwo.toString() + ")] step: " + costToEachOther.get(vicOne).get(vicTwo) + ", path: ");
					printPath(pathToEachOther.get(vicOne).get(vicTwo));
				}
			}
		}
	}
	
	// A* path finding algorithm with Location as the basic element
	public LinkedList<Location> aStarPathFinding(Location start, Location goal) {
		// initialize the data structures to be used in the search
		LinkedList<Location> openList = new LinkedList<Location>();
		Set<Location> closedList = new HashSet<Location>();
		HashMap<Location, Integer> values = new HashMap<Location, Integer>();
		HashMap<Location, Location> parents = new HashMap<Location, Location>();
		openList.add(start);
		values.put(start, 0);
		parents.put(start, null);
		boolean found = false;
		// start the search
		while (!(found || openList.isEmpty())) {
			// find the optimal grid with smallest f(n) = g(n) + h(n)
			Location besGrid = openList.get(0);
			for (Location grid: openList){
				if (values.get(grid) + grid.distanceManhattan(goal) < values.get(besGrid) + besGrid.distanceManhattan(goal)){
					besGrid = grid;
				}
			}
			// explore this grid
			openList.remove(besGrid);
			closedList.add(besGrid);
			Location nextGrid;
			for (int[] g: new int[][]{{-1,0}, {0,-1}, {0,1}, {1,0}}){
				int x = besGrid.x + g[0];
				int y = besGrid.y + g[1];
				nextGrid = new Location(x, y);
				if (y<=height-1 && x<=width-1 && y>=0 && x>=0 && !closedList.contains(nextGrid) && !values.containsKey(nextGrid) && !obstacles.contains(nextGrid)) {
					parents.put(nextGrid, besGrid);
					if (goal.equals(nextGrid)) {
						found = true;
						break;
					} else {
						openList.addFirst(nextGrid);
						values.put(nextGrid, 1+values.get(besGrid));
					}
				}
			}
			values.remove(besGrid);
		}
		// generate the path according to the results
		Location grid = goal;
		LinkedList<Location> path = new LinkedList<Location>();
		while (!grid.equals(start)) {
			path.addFirst(grid);
			grid = parents.get(grid);
		}
		return path;
	}
	
	
	
	// draw the map (for debugging purpose)
	public void visualize() {
		String str = "";
		for (int h=0; h<=height-1;h++){
			for (int w=0; w<=width-1; w++){
				if (obstacles.contains(new Location(w,h))){
					str += "1";
				} else if (victimsToVisit.contains(new Location(w,h))){
					str += "?";
				} else {
					str += "0";
				}
				str += " ";
			}
			str += "\n";
		}
		System.out.println(str);
	}
	
	// print the path generated by A* search algorithm (for debugging purpose)
	// a static method
	public void printPath(LinkedList<Location> path){
		for(int i=0; i<=path.size()-1; i++){
			System.out.print("("+path.get(i).toString()+")");
			if (i != path.size()-1) System.out.print("->");
		}
		System.out.println();
	}
	
	public void generateBestPathToVisitVictims() {
		// if there's no unvisited victims, return immediately
		if (victimsToVisit.size() == 0) {
			return;
		}
		
		for (Location vicOne: victimsToVisit) {
			for (Location vicTwo: victimsToVisit) {
				
			}
		}
	}
	
	public static void main(String[] args) {
		Location[] obstacles = new Location[]{new Location(2,1),new Location(2,3)};
		Location[] possibleVictims = new Location[]{new Location(2,2),new Location(5,6)};
		Set<Location> obstaclesSet = new HashSet<Location>(Arrays.asList(obstacles));
		Set<Location> possibleVictimsSet = new HashSet<Location>(Arrays.asList(possibleVictims));
		Model model = new Model(9, 8, obstaclesSet, possibleVictimsSet, true);
		model.visualize();
	}
}